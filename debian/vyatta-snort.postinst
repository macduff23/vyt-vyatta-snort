#!/bin/sh -e

CONFIG=/etc/snort/snort.debian.conf

. /usr/share/debconf/confmodule
test $DEBIAN_SCRIPT_DEBUG && set -v -x

# summary of how this script can be called:
#        * <postinst> `configure' <most-recently-configured-version>
#        * <old-postinst> `abort-upgrade' <new version>
#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
#          <new-version>
#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
#          <failed-install-package> <version> `removing'
#          <conflicting-package> <version>
# for details, see /usr/doc/packaging-manual/
#
# quoting from the policy:
#     Any necessary prompting should almost always be confined to the
#     post-installation script, and should be protected with a conditional
#     so that unnecessary prompting doesn't happen if a package's
#     installation fails and the `postinst' is called with `abort-upgrade',
#     `abort-remove' or `abort-deconfigure'.

case "$1" in
    install)
	;;
    upgrade)
	;;
    configure)
	# edit config file
	STARTUP=""
	INTERFACE=""
	ADDRESS_RANGE=""
	DISABLE_PROMISCUOUS=""
	REVERSE_ORDER=
	STATS_SEND=""
	STATS_RCPT=""
	STATS_THRESHOLD=""
	OPTIONS=""

	cat <<EOF >$CONFIG
# This file is used for options that are changed by Debian to leave
# the original lib files untouched.
# You have to use "dpkg-reconfigure snort" to change them.

DEBIAN_SNORT_STARTUP="$STARTUP"
DEBIAN_SNORT_HOME_NET="$ADDRESS_RANGE"
DEBIAN_SNORT_OPTIONS="$OPTIONS"
DEBIAN_SNORT_INTERFACE="$INTERFACE"
DEBIAN_SNORT_SEND_STATS="$STATS_SEND"
DEBIAN_SNORT_STATS_RCPT="$STATS_RCPT"
DEBIAN_SNORT_STATS_THRESHOLD="$STATS_THRESHOLD"
EOF

	if [ -f /etc/snort/snort.conf ]; then
		# Ensure the config file is readable by root.root and mode 600
		if ! dpkg-statoverride --list /etc/snort/snort.conf >/dev/null
		then
			chown root:snort /etc/snort/snort.conf
			chmod 640 /etc/snort/snort.conf
		fi
	fi

	db_stop
	;;
    abort-upgrade)
	;;
    *)
	echo "postinst called with unknown argument \`$1'" >&2
	exit 0
	;;
esac

if [ "$STARTUP" = "dialup" ]; then

	# Try to guess environments for all pppds we have no .env for...
	for PPPD_PID in $(pidof pppd ipppd); do
		# If we got an empty PID (however), we break here
		test "$PPPD_PID" || continue

		#
		# This is a lot of shell voodoo, let's try to figure it out:
		# 1. egrep:
		#    It greps for our current pppd PID in all pppd and ipppd
		#    pidfiles.
		#    It *should* return exactly one file name: the one with
		#    our current pppd PID in it; however, to be safe, we fence
		#    it with a head -1.
		# 2. basename $(egrep ...) .pid:
		#    It takes the file name from the egrep and strips off its
		#    path and the .pid suffix
		# 3. sed:
		#    Unfortunately the filenames of pppd and ipppd differ:
		#    pppd uses $INTERFACE.pid, while ipppd uses
		#    ipppd.$INTERFACE.pid.
		#    The .pid is already stripped off by basename, thus, we
		#    just strip off any "ipppd." prefix and end up in the
		#    plain interface name.
		#    Maybe pppd decides to change it's pidfile naming
		#    convention according to ipppd somewhere in the future,
		#    thus, we use '^i\?pppd\.' (sed eregex) and thus strip
		#    off all "ipppd." and all "pppd." prefixes. This doesn't
		#    harm anyways.
		#    Because of the pppd pidfile naming convention, our
		#    approach works always with ipppd and mostly with pppd:
		#    the latter only, if the user did not decide to rename
		#    his ppp interface to something else than ppp*
		#    (not possible currently, afaics).
		#
		PPP_IFACE=$(basename $(egrep -l "^[[:space:]]*$PPPD_PID[[:space:]]*\$" /var/run/ppp*.pid /var/run/ipppd.*.pid 2> /dev/null | head -1) .pid | sed -e 's/^i\?pppd\.//')

		#
		# If we got no interface from pidfiles (because there are no
		# pidfiles, for example), we assume the most common case:
		# one pppd with default route set.
		# This is ugly, but there is no other chance. Let's hope,
		# nobody ever manages multiple pppds without pidfiles for
		# them.
		#
		test "$PPP_IFACE" || PPP_IFACE=$(route -n |
			awk '/^0\.0\.0\.0 / { print $8 }')

		# If we couldn't discover an interface name, we break here
		test "$PPP_IFACE" || continue

		PPP_LOCAL=$(ifconfig $PPP_IFACE |
			awk '/inet addr:/ { gsub("addr:", ""); print $2 }')

		# If we couldn't discover a local IP, we break here
		test "$PPP_LOCAL" || continue

		ENVFILE=/var/run/snort_$PPP_IFACE.env

		# If we already have an .env for that interface, we break here
		test -e "$ENVFILE" && continue

		# Write .env for that interface
		echo "Creating missing $ENVFILE"
		echo "PPPD_PID=$PPPD_PID"    > "$ENVFILE"
		echo "PPP_IFACE=$PPP_IFACE" >> "$ENVFILE"
		echo "PPP_LOCAL=$PPP_LOCAL" >> "$ENVFILE"

		# If such a snort is still running, just kill it
		ps -ef | grep /usr/sbin/snort | grep "$PPP_LOCAL" |
			grep "$PPP_IFACE" | awk '{ print $2 }' |
			xargs --no-run-if-empty kill -s KILL >/dev/null
	done
fi

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

#DEBHELPER#

exit 0
